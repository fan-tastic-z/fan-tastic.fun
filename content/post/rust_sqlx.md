---
title: "Rust异步SQL库：sqlx"
date: 2024-06-29T13:16:13+08:00
tags: ["Rust"]
categories: ["Rust"]
draft: true
---

Go的生态中有一个非常出色访问数据库的访问库：sqlx, Rust的生态中也有一个sqlx, 也不知道两者是谁先谁后，但是相同的是，两者都是各自语言生态中非常优秀的库。

很多开发者大佬在开发中会优先选择自己构建sql避免使用各种复杂的ORM, 我自己之前是比较喜欢用ORM,觉得用起来更顺手，但是日常开发中很多时候，一些简单的常见，以及对数据库fake一些数据进行测试的时候，ORM 相对来说还是太笨重了，而Rust中的sqlx 就是一个提供了功能齐全的数据库访问和查询的库，支持常见的数据库。

注：sqlx 并不是ORM

这个笔记整理使用的数据库的数据库是Postgres

## sqlx-cli

在开始使用sqlx进行数据库的表的各种操作之前，需要了解一下 `sqlx-cli`工具的基本使用，`sql-cli`可以用于管理数据库，迁移数据库等。

安装：

```bash
cargo install --version='~0.7' sqlx-cli --no-default-features --features rustls,postgres
```

使用sqlx-cli对数据库进行相关操作的时候，需要指定`--database-url` 数据库的url, 当然我自己比较喜欢，在当前项目目录创建.env文件并添加`DATABASE_URL`

```env
# Postgres
DATABASE_URL=postgres://postgres:password@localhost:5432/sqlx_example
```

创建migration

```bash
sqlx migrate add <name>
```

执行上面命令会在当前目录下生成migrations目录，里面会有一个migration文件，我们需要在文件中添加相关sql语句

```SQL
-- Add migration script here
CREATE TYPE gender AS ENUM(
    'female',
    'male',
    'unknown'
);

CREATE TABLE user_stats(
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email varchar(128) NOT NULL UNIQUE,
    name varchar(64) NOT NULL,
    gender gender DEFAULT 'unknown',
    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    last_visited_at timestamptz,
    last_watched_at timestamptz,
    recent_watched int[],
    viewed_but_not_started int[],
    started_but_not_finished int[],
    finished int[],
    last_email_notification timestamptz,
    last_in_app_notification timestamptz,
    last_sms_notification timestamptz
);

CREATE INDEX user_stats_created_at_idx ON user_stats(created_at);

CREATE INDEX user_stats_last_visited_at_idx ON user_stats(last_visited_at);

CREATE INDEX user_stats_last_watched_at_idx ON user_stats(last_watched_at);

CREATE INDEX user_stats_recent_watched_idx ON user_stats USING GIN(recent_watched);

CREATE INDEX user_stats_viewed_but_not_started_idx ON user_stats USING GIN(viewed_but_not_started);

CREATE INDEX user_stats_started_but_not_finished_idx ON user_stats USING GIN(started_but_not_finished);

CREATE INDEX user_stats_last_email_notification_idx ON user_stats(last_email_notification);

CREATE INDEX user_stats_last_in_app_notification_idx ON user_stats(last_in_app_notification);

CREATE INDEX user_stats_last_sms_notification_idx ON user_stats(last_sms_notification);

```

执行migration:

```bash
sqlx migrate run
```

即可以在数据库中创建了user_stats表和migration记录表

## 批量插入数据

在平时开发中，批量的插入数据在日常业务开发中也是经常使用，同时当我们需要给数据批量生成一些测试数据时也经常会用到，sqlx 也提供了批量插入数据`push_values` 方法。<https://docs.rs/sqlx-core/latest/sqlx_core/query_builder/struct.QueryBuilder.html#method.push_values>

通过 `QueryBuilder` 进行sql 语句构造，主要内容为：

```rust
 let mut query_builder: QueryBuilder<Postgres> = QueryBuilder::new(
        r"INSERT INTO user_stats (
            email,
            name,
            gender,
            created_at,
            last_visited_at,
            last_watched_at,
            recent_watched,
            viewed_but_not_started,
            started_but_not_finished,
            finished,
            last_email_notification,
            last_in_app_notification,
            last_sms_notification
        ) ",
    );
    query_builder.push_values(users, |mut b, user| {
        b.push_bind(user.email)
            .push_bind(user.name)
            .push_bind(user.gender)
            .push_bind(user.created_at)
            .push_bind(user.last_visited_at)
            .push_bind(user.last_watched_at)
            .push_bind(user.recent_watched)
            .push_bind(user.viewed_but_not_started)
            .push_bind(user.started_but_not_finished)
            .push_bind(user.finished)
            .push_bind(user.last_email_notification)
            .push_bind(user.last_in_app_notification)
            .push_bind(user.last_sms_notification);
    });
    query_builder.build().execute(pool).await?;
```
